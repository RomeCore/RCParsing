using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using RCParsing.ParserRules;
using RCParsing.TokenPatterns;

namespace RCParsing
{
#pragma warning disable IDE1006 // Naming Styles

	/// <summary>
	/// Represents a parsed rule in the AST (Abstract Syntax Tree) generated by parsing a language grammar.
	/// </summary>
	public struct ParsedRule
	{
		/// <summary>
		/// The value indicates whether the parsing was successful.
		/// </summary>
		public readonly bool success => element.success;

		/// <summary>
		/// The ID of the child token pattern that was parsed.
		/// </summary>
		public int ruleId;

		/// <summary>
		/// The starting index of the rule in the input text.
		/// </summary>
		public int startIndex { readonly get => element.startIndex; set => element.startIndex = value; }

		/// <summary>
		/// The length of the rule in the input text.
		/// </summary>
		public int length { readonly get => element.length; set => element.length = value; }

		/// <summary>
		/// The count of passed barrier tokens.
		/// </summary>
		public int passedBarriers;

		/// <summary>
		/// Gets the intermediate value associated with this rule, basically got from child token.
		/// </summary>
		public object? intermediateValue { readonly get => element.intermediateValue; set => element.intermediateValue = value; }

		/// <summary>
		/// Gets the parsed element information associated with this rule.
		/// </summary>
		public ParsedElement element;

		/// <summary>
		/// Gets the occurency index of this rule within its parent rule. -1 by default.
		/// </summary>
		public int occurency;

		/// <summary>
		/// Gets the children rules of this rule. Valid for parallel and sequence rules.
		/// </summary>
		public IReadOnlyList<ParsedRule>? children;

		/// <summary>
		/// Gets a parsed rule that represents failure.
		/// </summary>
		public static readonly ParsedRule Fail = new()
		{
			element = ParsedElement.Fail,
			ruleId = -1
		};

		/// <summary>
		/// Creates a parsed rule that represents success token.
		/// </summary>
		/// <param name="ruleId">The ID of the rule that was parsed.</param>
		/// <param name="startIndex">The starting index of the token in the input text.</param>
		/// <param name="length">The length of the token in the input text.</param>
		/// <param name="passedBarriers">The count of passed barrier tokens.</param>
		/// <param name="intermediateValue">The intermediate value associated with this token.</param>
		/// <returns>A parsed rule that represents success token.</returns>
		public static ParsedRule Token(int ruleId, int startIndex, int length, int passedBarriers, object? intermediateValue)
		{
			return new ParsedRule
			{
				ruleId = ruleId,
				element = new ParsedElement(startIndex, length, intermediateValue),
				passedBarriers = passedBarriers
			};
		}

		/// <summary>
		/// Creates a parsed rule.
		/// </summary>
		/// <param name="ruleId">The ID of the rule that was parsed.</param>
		/// <param name="startIndex">The starting index of the rule in the input text.</param>
		/// <param name="length">The length of the rule in the input text.</param>
		/// <param name="passedBarriers">The count of passed barrier tokens.</param>
		/// <param name="children">The array of child rules.</param>
		/// <param name="intermediateValue">The intermediate value associated with this rule.</param>
		/// <returns>A parsed rule.</returns>
		public static ParsedRule Rule(int ruleId, int startIndex, int length, int passedBarriers, IReadOnlyList<ParsedRule> children, object? intermediateValue = null)
		{
			return new ParsedRule
			{
				ruleId = ruleId,
				element = new ParsedElement(startIndex, length, intermediateValue),
				passedBarriers = passedBarriers,
				children = children
			};
		}
	}
}