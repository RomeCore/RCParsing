using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using RCParsing.ParserRules;
using RCParsing.TokenPatterns;

namespace RCParsing
{
#pragma warning disable IDE1006 // Naming Styles

	/// <summary>
	/// Represents a parsed rule in the AST (Abstract Syntax Tree) generated by parsing a language grammar.
	/// </summary>
	public struct ParsedRule
	{
		/// <summary>
		/// The value indicates whether the parsing was successful.
		/// </summary>
		public bool success { readonly get => element.success; set => element.success = value; }

		/// <summary>
		/// The value indicating that this element should be excluded from AST.
		/// </summary>
		public bool excludeFromAst { readonly get => element.excludeFromAst; set => element.excludeFromAst = value; }

		/// <summary>
		/// The ID of the child token pattern that was parsed.
		/// </summary>
		public int ruleId { readonly get => element.elementId; set => element.elementId = value; }

		/// <summary>
		/// The starting index of the rule in the input text.
		/// </summary>
		public int startIndex { readonly get => element.startIndex; set => element.startIndex = value; }

		/// <summary>
		/// The length of the rule in the input text.
		/// </summary>
		public int length { readonly get => element.length; set => element.length = value; }

		/// <summary>
		/// The count of passed barrier tokens.
		/// </summary>
		public int passedBarriers;

		/// <summary>
		/// Gets the intermediate value associated with this rule, basically got from child token.
		/// </summary>
		public object? intermediateValue { readonly get => element.intermediateValue; set => element.intermediateValue = value; }

		/// <summary>
		/// The ID of the rule that was parsed. Or -1 if it is not a token.
		/// </summary>
		public int tokenId;

		/// <summary>
		/// Gets the parsed element information associated with this rule.
		/// </summary>
		public ParsedElement element;

		/// <summary>
		/// Gets the value indicating whether this rule represents a token.
		/// </summary>
		public readonly bool isToken => tokenId != -1;

		/// <summary>
		/// Gets the occurency index of this rule within its parent rule. -1 by default.
		/// </summary>
		public int occurency;

		/// <summary>
		/// Gets the children rules of this rule. Valid for parallel and sequence rules.
		/// </summary>
		public IReadOnlyList<ParsedRule>? children;

		/// <summary>
		/// Gets a parsed rule that represents failure.
		/// </summary>
		public static ParsedRule Fail { get; } = new ParsedRule { element = ParsedElement.Fail, tokenId = -1 };

		/// <summary>
		/// Creates a parsed rule that represents success token.
		/// </summary>
		/// <param name="ruleId">The ID of the rule that was parsed.</param>
		/// <param name="tokenId">The ID of the token pattern that was parsed.</param>
		/// <param name="startIndex">The starting index of the token in the input text.</param>
		/// <param name="length">The length of the token in the input text.</param>
		/// <param name="passedBarriers">The count of passed barrier tokens.</param>
		/// <param name="intermediateValue">The intermediate value associated with this token.</param>
		/// <returns>A parsed rule that represents success token.</returns>
		public static ParsedRule Token(int ruleId, int tokenId, int startIndex, int length, int passedBarriers, object? intermediateValue)
		{
			return new ParsedRule
			{
				element = new ParsedElement(ruleId, startIndex, length, intermediateValue),
				passedBarriers = passedBarriers,
				tokenId = tokenId,
				occurency = -1
			};
		}

		/// <summary>
		/// Creates a parsed rule.
		/// </summary>
		/// <param name="ruleId">The ID of the rule that was parsed.</param>
		/// <param name="startIndex">The starting index of the rule in the input text.</param>
		/// <param name="length">The length of the rule in the input text.</param>
		/// <param name="passedBarriers">The count of passed barrier tokens.</param>
		/// <param name="children">The array of child rules.</param>
		/// <param name="intermediateValue">The intermediate value associated with this rule.</param>
		/// <returns>A parsed rule.</returns>
		public static ParsedRule Rule(int ruleId, int startIndex, int length, int passedBarriers, IReadOnlyList<ParsedRule> children, object? intermediateValue = null)
		{
			return new ParsedRule
			{
				element = new ParsedElement(ruleId, startIndex, length, intermediateValue),
				passedBarriers = passedBarriers,
				tokenId = -1,
				occurency = -1,
				children = children
			};
		}
	}
}