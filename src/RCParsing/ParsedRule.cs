using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using RCParsing.ParserRules;
using RCParsing.TokenPatterns;

namespace RCParsing
{
#pragma warning disable IDE1006 // Naming Styles

	/// <summary>
	/// Represents a parsed rule in the AST (Abstract Syntax Tree) generated by parsing a language grammar.
	/// </summary>
	public struct ParsedRule
	{
		/// <summary>
		/// The value indicates whether the parsing was successful.
		/// </summary>
		public bool success { readonly get => element.success; set => element.success = value; }

		/// <summary>
		/// The ID of the child token pattern that was parsed.
		/// </summary>
		public int ruleId { readonly get => element.elementId; set => element.elementId = value; }

		/// <summary>
		/// The starting index of the rule in the input text.
		/// </summary>
		public int startIndex { readonly get => element.startIndex; set => element.startIndex = value; }

		/// <summary>
		/// The length of the rule in the input text.
		/// </summary>
		public int length { readonly get => element.length; set => element.length = value; }

		/// <summary>
		/// Gets the intermediate value associated with this rule.
		/// </summary>
		/// <remarks>
		/// For <see cref="SequenceTokenPattern"/> or <see cref="RepeatTokenPattern"/> it will be <see langword="null"/>. <br/>
		/// For <see cref="ChoiceTokenPattern"/> it will be the selected inner value. <br/>
		/// For <see cref="OptionalTokenPattern"/> it will be the inner value if present, otherwise null.
		/// <para/>
		/// For leaf token implementations this may be, for example,
		/// <see cref="Match"/> for <see cref="RegexTokenPattern"/>. <br/>
		/// See remarks for specific implementations.
		/// </remarks>
		public object? intermediateValue { readonly get => element.intermediateValue; set => element.intermediateValue = value; }

		/// <summary>
		/// The ID of the rule that was parsed.
		/// </summary>
		public int tokenId;

		/// <summary>
		/// Gets the parsed element information associated with this rule.
		/// </summary>
		public ParsedElement element;

		/// <summary>
		/// Gets the value indicating whether this rule represents a token.
		/// </summary>
		public bool isToken;

		/// <summary>
		/// Gets the occurency index of this rule within its parent rule. -1 by default.
		/// </summary>
		public int occurency;

		/// <summary>
		/// Gets the children rules of this rule. Valid for parallel and sequence rules.
		/// </summary>
		public IReadOnlyList<ParsedRule>? children;

		/// <summary>
		/// Gets a parsed rule that represents failure.
		/// </summary>
		public static ParsedRule Fail { get; } = new ParsedRule { element = ParsedElement.Fail, tokenId = -1, isToken = false };

		/// <summary>
		/// Creates a parsed rule that represents success token.
		/// </summary>
		/// <param name="ruleId">The ID of the rule that was parsed.</param>
		/// <param name="tokenId">The ID of the token pattern that was parsed.</param>
		/// <param name="startIndex">The starting index of the token in the input text.</param>
		/// <param name="length">The length of the token in the input text.</param>
		/// <param name="intermediateValue">The intermediate value associated with this token.</param>
		/// <returns>A parsed rule that represents success token.</returns>
		public static ParsedRule Token(int ruleId, int tokenId, int startIndex, int length, object? intermediateValue)
		{
			return new ParsedRule
			{
				element = new ParsedElement(tokenId, startIndex, length, intermediateValue),
				ruleId = ruleId,
				tokenId = tokenId,
				isToken = true,
				occurency = -1
			};
		}

		/// <summary>
		/// Creates a parsed rule.
		/// </summary>
		/// <param name="ruleId">The ID of the rule that was parsed.</param>
		/// <param name="startIndex">The starting index of the rule in the input text.</param>
		/// <param name="length">The length of the rule in the input text.</param>
		/// <param name="children">The array of child rules.</param>
		/// <param name="intermediateValue">The intermediate value associated with this rule.</param>
		/// <returns>A parsed rule.</returns>
		public static ParsedRule Rule(int ruleId, int startIndex, int length, IReadOnlyList<ParsedRule> children, object? intermediateValue = null)
		{
			return new ParsedRule
			{
				tokenId = -1,
				element = new ParsedElement(ruleId, startIndex, length, intermediateValue),
				isToken = false,
				occurency = -1,
				children = children
			};
		}
	}
}