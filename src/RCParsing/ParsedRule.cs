using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using RCParsing.ParserRules;
using RCParsing.TokenPatterns;

namespace RCParsing
{
#pragma warning disable IDE1006 // Naming Styles

	/// <summary>
	/// Represents a parsed rule in the AST (Abstract Syntax Tree) generated by parsing a rule.
	/// </summary>
	public struct ParsedRule
	{
		/// <summary>
		/// The value indicates whether the parsing was successful.
		/// </summary>
		public readonly bool success => element.success;

		/// <summary>
		/// The ID of the child token pattern that was parsed.
		/// </summary>
		public int ruleId;

		/// <summary>
		/// The starting index of the rule in the input text.
		/// </summary>
		public int startIndex { readonly get => element.startIndex; set => element.startIndex = value; }

		/// <summary>
		/// The length of the rule in the input text.
		/// </summary>
		public int length { readonly get => element.length; set => element.length = value; }

		/// <summary>
		/// The count of passed barrier tokens.
		/// </summary>
		public int passedBarriers;

		/// <summary>
		/// Gets the intermediate value associated with this rule, basically got from child token.
		/// </summary>
		public object? intermediateValue { readonly get => element.intermediateValue; set => element.intermediateValue = value; }

		/// <summary>
		/// Gets the parsed element information associated with this rule.
		/// </summary>
		public ParsedElement element;

		/// <summary>
		/// Gets the occurency index of this rule within its parent rule. -1 by default.
		/// </summary>
		public int occurency;

		/// <summary>
		/// Gets the version number of this parsed rule. Used for tracking chages in incremental parsing.
		/// </summary>
		public int version;

		/// <summary>
		/// Gets the children rules of this rule. Valid for parallel and sequence rules.
		/// </summary>
		public IReadOnlyList<ParsedRule>? children;

		/// <summary>
		/// Gets a parsed rule that represents failure.
		/// </summary>
		public static readonly ParsedRule Fail = new ParsedRule(
			ruleId: -1,
			element: ParsedElement.Fail
		);

		/// <summary>
		/// Initializes a <see cref="ParsedRule"/> struct with children.
		/// </summary>
		/// <param name="ruleId">The ID of the rule that was parsed.</param>
		/// <param name="children">The sequence of child rules.</param>
		public ParsedRule(int ruleId, params ParsedRule[] children)
		{
			int startIndex = int.MaxValue;
			int endIndex = int.MinValue;
			int passedBarriers = 0;

			for (int i = 0; i < children.Length; i++)
			{
				var child = children[i];
				if (!child.success)
					continue;
				if (startIndex > child.startIndex)
					startIndex = child.startIndex;
				var _endIndex = child.startIndex + child.length;
				if (endIndex < _endIndex)
					endIndex = _endIndex;
				if (passedBarriers < child.passedBarriers)
					passedBarriers = child.passedBarriers;
			}

			if (startIndex < 0 || startIndex == int.MaxValue)
			{
				this.ruleId = -1;
				this.element = ParsedElement.Fail;
				this.passedBarriers = 0;
				this.occurency = -1;
				this.version = 0;
				this.children = null;
				return;
			}

			this.ruleId = ruleId;
			this.element = new ParsedElement(startIndex, endIndex);
			this.passedBarriers = passedBarriers;
			this.occurency = -1;
			this.version = 0;
			this.children = children;
		}

		/// <summary>
		/// Initializes a <see cref="ParsedRule"/> struct as successful parse with no child.
		/// </summary>
		/// <param name="ruleId">The ID of the rule that was parsed.</param>
		/// <param name="startIndex">The starting index of the token in the input text.</param>
		/// <param name="length">The length of the token in the input text.</param>
		/// <param name="passedBarriers">The count of passed barrier tokens.</param>
		public ParsedRule(int ruleId, int startIndex, int length, int passedBarriers)
		{
			this.ruleId = ruleId;
			this.element = new ParsedElement(startIndex, length);
			this.passedBarriers = passedBarriers;
			this.occurency = -1;
			this.version = 0;
			this.children = null;
		}
		
		/// <summary>
		/// Initializes a <see cref="ParsedRule"/> struct as successful parse with no child.
		/// </summary>
		/// <param name="ruleId">The ID of the rule that was parsed.</param>
		/// <param name="startIndex">The starting index of the token in the input text.</param>
		/// <param name="length">The length of the token in the input text.</param>
		/// <param name="passedBarriers">The count of passed barrier tokens.</param>
		/// <param name="intermediateValue">The intermediate value associated with this token.</param>
		public ParsedRule(int ruleId, int startIndex, int length, int passedBarriers, object? intermediateValue)
		{
			this.ruleId = ruleId;
			this.element = new ParsedElement(startIndex, length, intermediateValue);
			this.passedBarriers = passedBarriers;
			this.occurency = -1;
			this.version = 0;
			this.children = null;
		}

		/// <summary>
		/// Initializes a <see cref="ParsedRule"/> struct with children.
		/// </summary>
		/// <param name="ruleId">The ID of the rule that was parsed.</param>
		/// <param name="startIndex">The starting index of the rule in the input text.</param>
		/// <param name="length">The length of the rule in the input text.</param>
		/// <param name="passedBarriers">The count of passed barrier tokens.</param>
		/// <param name="children">The collection of child rules.</param>
		public ParsedRule(int ruleId, int startIndex, int length, int passedBarriers, IReadOnlyList<ParsedRule> children)
		{
			this.ruleId = ruleId;
			this.element = new ParsedElement(startIndex, length);
			this.passedBarriers = passedBarriers;
			this.occurency = -1;
			this.version = 0;
			this.children = children;
		}
		
		/// <summary>
		/// Initializes a <see cref="ParsedRule"/> struct with children.
		/// </summary>
		/// <param name="ruleId">The ID of the rule that was parsed.</param>
		/// <param name="startIndex">The starting index of the rule in the input text.</param>
		/// <param name="length">The length of the rule in the input text.</param>
		/// <param name="passedBarriers">The count of passed barrier tokens.</param>
		/// <param name="intermediateValue">The intermediate value associated with this rule (optional).</param>
		/// <param name="children">The collection of child rules.</param>
		public ParsedRule(int ruleId, int startIndex, int length, int passedBarriers, object? intermediateValue, IReadOnlyList<ParsedRule> children)
		{
			this.ruleId = ruleId;
			this.element = new ParsedElement(startIndex, length, intermediateValue);
			this.passedBarriers = passedBarriers;
			this.occurency = -1;
			this.version = 0;
			this.children = children;
		}

		/// <summary>
		/// Initializes a <see cref="ParsedRule"/> struct with children.
		/// </summary>
		/// <param name="ruleId">The ID of the rule that was parsed.</param>
		/// <param name="startIndex">The starting index of the rule in the input text.</param>
		/// <param name="length">The length of the rule in the input text.</param>
		/// <param name="passedBarriers">The count of passed barrier tokens.</param>
		/// <param name="children">The sequence of child rules.</param>
		public ParsedRule(int ruleId, int startIndex, int length, int passedBarriers, params ParsedRule[] children)
		{
			this.ruleId = ruleId;
			this.element = new ParsedElement(startIndex, length);
			this.passedBarriers = passedBarriers;
			this.occurency = -1;
			this.version = 0;
			this.children = children;
		}

		/// <summary>
		/// Initializes a <see cref="ParsedRule"/> struct with children.
		/// </summary>
		/// <param name="ruleId">The ID of the rule that was parsed.</param>
		/// <param name="startIndex">The starting index of the rule in the input text.</param>
		/// <param name="length">The length of the rule in the input text.</param>
		/// <param name="passedBarriers">The count of passed barrier tokens.</param>
		/// <param name="intermediateValue">The intermediate value associated with this rule (optional).</param>
		/// <param name="children">The sequence of child rules.</param>
		public ParsedRule(int ruleId, int startIndex, int length, int passedBarriers, object? intermediateValue, params ParsedRule[] children)
		{
			this.ruleId = ruleId;
			this.element = new ParsedElement(startIndex, length, intermediateValue);
			this.passedBarriers = passedBarriers;
			this.occurency = -1;
			this.version = 0;
			this.children = children;
		}

		/// <summary>
		/// Initializes a parsed rule with custom element and ruleId.
		/// </summary>
		/// <param name="ruleId">The rule ID.</param>
		/// <param name="element">The parsed element information.</param>
		public ParsedRule(int ruleId, ParsedElement element)
		{
			this.ruleId = ruleId;
			this.element = element;
			this.passedBarriers = 0;
			this.occurency = -1;
			this.version = 0;
			this.children = null;
		}

		/// <summary>
		/// Moves the start index of the parsed rule and its children by a specified amount.
		/// </summary>
		/// <param name="delta">The amount to move the start index by.</param>
		/// <returns>A new parsed rule with the updated start index.</returns>
		public readonly ParsedRule Move(int delta)
		{
			ParsedRule result = this;

			result.startIndex += delta;

			if (children != null)
			{
				var newChildren = new ParsedRule[children.Count];
				for (int i = 0; i < children.Count; i++)
					newChildren[i] = children[i].Move(delta);
				result.children = newChildren;
			}

			return result;
		}

		/// <summary>
		/// Changes the version number of this parsed rule. Used for tracking changes in incremental parsing.
		/// </summary>
		/// <param name="newVersion">The new version number.</param>
		public readonly ParsedRule ChangeVersion(int newVersion)
		{
			ParsedRule result = this;

			result.version = newVersion;

			if (children != null)
			{
				var newChildren = new ParsedRule[children.Count];
				for (int i = 0; i < children.Count; i++)
					newChildren[i] = children[i].ChangeVersion(newVersion);
				result.children = newChildren;
			}

			return result;
		}
	}
}